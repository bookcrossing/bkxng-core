<?php

/**
 * @file
 * Bookcrossing features.
 */

/**
 @todo string with author and year
 @todo search
 */
define('BOOKCROSSING_RESERVED_BCIDS', 5);
define('BOOKCROSSING_BOOK_STATUS_FREE', 0);
define('BOOKCROSSING_BOOK_STATUS_FOUND', 1);
define('BOOKCROSSING_BOOK_STATUS_RESERVED', 2);
define('BOOKCROSSING_PLACES_VID', 3); // ID of vocabulary that stores places - @todo: Add vocabulary id to settings
define('BOOKCROSSING_CURRENT', 0);
require_once ('bookcrossing.menu.inc');
require_once ('bookcrossing.blocks.inc');
require_once ('bcid/Bcid.inc');
// require_once('bookcrossing.socialicons.inc');
//require_once ('bookcrossing.nodetypes.inc');

/**
 * Implements hook_init().
 */
function bookcrossing_init()
{
    // again :(
    module_load_include('inc', 'node', 'node.pages');

    // loading library for working with ajax
    drupal_add_library('system', 'drupal.ajax');
}


/**
 * Implements hook_permission().
 *
 */
function bookcrossing_permission()
{
    return array(
        'release book' => array(
            'title' => t('Release book'),
        ),
        'register found book' => array(
            'title' => t('Ability to register found book'),
        ),
        'change review' => array(
            'title' => t('Change review'),
        ),
        'administer books' => array(
            'title' => t('Administer books'),
        ),
        'add to bookmarks' => array(
            'title' => t('Add to bookmarks'),
        ),
        'view users list' => array(
            'title' => t('View users list'),
        ),
    );
}

/**
 * Form for search books.
 *
 * @param $form
 * @param $form_state
 *
 * @return array
 */
function bookcrossing_search_form($form, $form_state)
{
// @todo: Why this function accepts $form and $form_state?
    $form = array();
    $form['title'] = array(
        '#markup' => '<div class="search-title">' . t('Search for a book') . '</div>',
    );
    $form['search'] = array(
        '#type' => 'textfield',
        '#size' => 40,
    );
    $form['submit'] = array(
        '#type' => 'image_button',
        '#src' => drupal_get_path('theme', 'bootstrap_bookcrossing') . '/images/search.png',
        '#value' => t('Search'),
    );
    $form['description'] = array(
        '#markup' => '<p class="help-block">' . t('Enter book title or author name or ISBN') . '</p>',
    );
    return $form;
}

/**
 * Submit for search form
 *
 * @param $form
 * @param $form_state
 *
 */
function bookcrossing_search_form_validate($form, &$form_state){
    if (empty($form_state['values']['search'])) {
        form_set_error('search', t('Enter book title or author name or ISBN to look for books'));
    }
}

/**
 * @param $form
 * @param $form_state
 */
function bookcrossing_search_form_submit($form, &$form_state)
{
    unset($_GET['destination']);
    drupal_goto(url('books', array('absolute' => TRUE, 'query' => array('find' => $form_state['values']['search']))));
}

/**
 * Form for entering bcid of the found book
 * @param $form
 * @param $form_state
 * @return array
 */
function bookcrossing_books_form($form, $form_state)
{
// @todo: Why this function accepts $form and $form_state?
    $form = array();
    $form['title'] = array(
        '#markup' => '<div class="bcid-title">' . t('Register book as found') . '</div>',
    );
    $form['bcid-first-part'] = array(
        '#type' => 'textfield',
        '#size' => 10,
        '#required' => TRUE,
        '#attributes' => array(
        'maxlength' => 5,
        ),
    );
    $form['bcid-second-part'] = array(
        '#type' => 'textfield',
        '#prefix' => '<div class="bcid-separator">-</div>',
        '#required' => TRUE,
        '#size' => 10,
        '#attributes' => array(
        'maxlength' => 4,
        ),
    );
    $form['submit'] = array(
        '#type' => 'image_button',
        '#src' => drupal_get_path('theme', 'bootstrap_bookcrossing') . '/images/arrow-go.png',
        '#value' => t('Found a book'),
        '#attributes' => array(
            'class' => array('bcid-submit'),
        ),
    );
    $form['description'] = array(
        '#markup' => '<p class="help-block">' . t('Enter BCID of the book you have found') . '</p>',
    );
    return $form;
}

/**
 * @param $form
 * @param $form_state
 */
function bookcrossing_books_form_validate($form, &$form_state){
    $bcid = $form_state['values']['bcid-first-part'] . '-' . $form_state['values']['bcid-second-part'];
    $book = bookcrossing_load_by_bcid($bcid);
    /**
     * There is no that book in db.
     */
    if (!$book) {
        form_set_error('search', t('There is no record in our catalog for book with BCID you have entered'));
    }
    /**
     * Someone already found this book.
     */
    if (isset($book['status']) && $book['status']) {
        form_set_error('search', t('Seems someone has found this book and have not released it yet. If you can not proceed with book registration, please contact site administration.'));
    }
}

/**
 * Form submit: show info about book with entered bcid.
 */
function bookcrossing_books_form_submit($form, &$form_state)
{
    unset($_GET['destination']);
    drupal_goto('found-book/' . $form_state['values']['bcid-first-part'] . '-' . $form_state['values']['bcid-second-part']);
}

function bookcrossing_permission_forms_callback($page='')
{
    global $conf, $user;
    if ($page=='user')
        if ($user->uid == 0) {
            return isset($conf['access_login_form']) ? $conf['access_login_form'] : FALSE;
        } else {
            return TRUE;
        }

    return isset($conf['access_login_form']) ? $conf['access_login_form'] : FALSE;
}

/**
 * Menu callback: users shelf
 *
 * @param object $account
 *   user object
 *
 * @return string
 *   html string of users shelf
 */
function bookcrossing_users_shelf($account = NULL)
{
    if (!$account) {
        global $user;
        $account = $user;
    }

    // Favourites / Bookmarks
    $favourites = db_select('bookcrossing_favourites', 'f')
        ->fields('f', array('bid'))
        ->condition('f.uid', $account->uid, '=')
        ->execute()
        ->fetchCol();

    $favourites_books = bookcrossing_load_multiple($favourites);

    // Loading books user currently reading.
    $current_bids = db_select('bookcrossing_books', 'book')
        ->fields('book', array('bid'))
        ->condition('owner', $account->uid, '=')
        ->condition('status', BOOKCROSSING_BOOK_STATUS_RESERVED, '<>')
        ->execute()
        ->fetchCol();

    $current_books = bookcrossing_load_multiple($current_bids);

    // Loading books user read.
    $read_bids = db_select('bookcrossing_history', 'history')
        ->fields('history', array('book_id'))
        ->distinct()
        ->condition('user_id', $account->uid, '=')
        ->execute()
        ->fetchCol();
    $read_books = bookcrossing_load_multiple($read_bids);
    $output = '';
    if ($favourites_books) {
        $output .= '<h3 class="favourites-books-title">' . t('Bookmarks') . '</h3>';
        $output .= bookcrossing_books_table($favourites_books, 'book_shelf');
    }
    if ($current_books) {
        $output .= '<h3 class="found-books-title">' . t('Found books') . '</h3>';
        $output .= bookcrossing_books_table($current_books, 'book_shelf_with_bcid', 3, TRUE);
    }
    if ($read_books) {
        $output .= '<h3 class="released-books-title">' . t('Released books') . '</h3>';
        $output .= bookcrossing_books_table($read_books, 'book_shelf_with_bcid');
    }

    return $output;
}


/**
 * Helper function: books table.
 *
 * @param array $books
 *   array with books which should be displayed in table
 *
 * @param $mode
 * @param int $num_in_row
 *   number of books in one table row
 *
 * @param bool $release_link
 * @return string html for table with books
 * html for table with books
 */
function bookcrossing_books_table($books, $mode, $num_in_row = 3, $release_link = FALSE)
{
    $i = 0;
    $count = 0;
    $rows = array();

    foreach ($books as $book) {
        if ($count == $num_in_row) {
            $i++;
            $count = 0;
        }

        $view = node_view($book['node'], $mode);
        $view['bcid'] = array(
            '#markup' => '<div class="books-bcid">BCID: ' . $book['bcid'] . '</div>',
        );

        $view['author_and_year'] = array(
            '#markup' => bookcrossing_author_and_year($book),
        );

        $view = bookcrossing_prepare_book_view($view, $book, FALSE);
        $link = $release_link ? l('&nbsp;', 'release-book/' . $book['bid'], array('html' => TRUE, 'attributes' => array('class' => array('release-link'), 'title' => t('Release book')))) : '';

        $rows[$i] = array();
        $rows[$i][] = render($view) . $link;
        $count++;
    }

    return theme('table', array(
                            'header' => array(),
                            'rows' => $rows,
                            'sticky' => FALSE,
                            'attributes' => array(
                                'class' => array('user-shelf')
                            )
                        )
            );
}

/**
 * Formatting string with book authors and year
 */
function bookcrossing_author_and_year($book)
{
    $authors = array();
    $publish_year = "";

    foreach ($book['node']->field_bookcrossing_author[LANGUAGE_NONE] as $tid) {
        $term = taxonomy_term_load($tid['tid']);
        $authors[] = $term->name;
    }
    $output = "<span class=\"book-authors\">" . implode(', ', $authors);

    if (isset($book['node']->field_bookcrossing_year[LANGUAGE_NONE])) {
        $publish_year = $book['node']->field_bookcrossing_year[LANGUAGE_NONE][0]['value'];
        $output .= ",</span> <span class=\"book-publish-year\">" . $publish_year . "</span>";
    } else {
        $output .= "</span>";
    }

    return $output;
}

/**
 * Implements hook_taxonomy_term_save().
 */
function bookcrossing_taxonomy_term_insert($term)
{
    if (isset($term->merged_terms) && $term->vid == BOOKCROSSING_PLACES_VID) {
        db_update('bookcrossing_books')
            ->fields(array('current_place' => $term->tid))
            ->condition('current_place', $term->merged_terms, 'IN')
            ->execute();

        db_update('bookcrossing_history')
            ->fields(array('place_id' => $term->tid))
            ->condition('place_id', $term->merged_terms, 'IN')
            ->execute();
    }
}

function bookcrossing_places_autocomplete_results($parent, $string)
{
    $suggestions = array();

    if (!empty($string)) {
        $query = db_select('taxonomy_term_data', 't');
        $query->innerJoin('taxonomy_term_hierarchy', 'h', 't.tid = h.tid');
        $suggestions = $query->fields('t', array('name'))
            ->condition('t.vid', BOOKCROSSING_PLACES_VID, '=')
            ->condition('h.parent', $parent, '=')
            ->condition('t.name', $string . '%', 'LIKE')
            ->execute()
            ->fetchCol();
    }

    drupal_json_output(drupal_map_assoc($suggestions));
}

/**
 * Form for changing users comment to the book.
 *
 */

function bookcrossing_change_comment_form($form, &$form_state, $info)
{
    $form = array();

    /**
     * Adding info about book the existence of user comment.
     *
     */
    $exists = db_select('bookcrossing_comment', 'comment')
        ->fields('comment', array('comment'))
        ->condition('uid', $info['uid'], '=')
        ->condition('bid', $info['bid'], '=')
        ->execute()
        ->fetchField();

    $form_state['info'] = $info;
    $form_state['exists'] = $exists ? TRUE : FALSE;

    $form['comment'] = array(
        '#type' => 'textarea',
        '#default_value' => $exists,
    );

    $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Save'),
        '#ajax' => array(
            'callback' => 'bookcrossing_save_comment_ajax',
        ),
        '#submit' => array(),
    );

    return $form;
}


/**
 * Ajax callback: save updated comment.
 *
 * If user already have comment then it will be updated, if not then the new one will be created.
 * Each user can have 1 comment for every book.
 *
 */
function bookcrossing_save_comment_ajax($form, $form_state)
{
    $commands = array();

    // Check the users comment text.
    $comment = strip_tags(filter_xss($form_state['values']['comment']));

    if ($form_state['exists'])
    {
        db_update('bookcrossing_comment')
            ->fields(array('comment' => $comment))
            ->condition('bid', $form_state['info']['bid'], '=')
            ->condition('uid', $form_state['info']['uid'], '=')
            ->execute();
    }
    else
    {
        db_insert('bookcrossing_comment')
            ->fields(array('bid' => $form_state['info']['bid'], 'uid' => $form_state['info']['uid'], 'comment' => $comment))
            ->execute();
    }

    // Add updated comment to the page.
    $commands[] = ajax_command_html('#my-comment-text', $comment);
    $commands[] = ajax_command_html('.history-comment.my-comment', $comment);

    return array('#type' => 'ajax', '#commands' => $commands);
}


/**
 * Helper function: adds og meta data.
 *
 * @param string $property
 *   og property name
 *
 * @param string $content
 *   og content
 *
 * @return array
 *   An array of all stored HEAD elements.
 *
 */
function bookcrossing_meta_og_add($property, $content, $index = 0)
{
    return drupal_add_html_head(
        array(
            '#tag' => 'meta',
            '#attributes' => array(
                'property' => $property,
                'content' => $content,
            ),
        ),
        $index ? str_replace( array(':','.'), '_', $property ).'_'.strval($index) : str_replace( array(':','.'), '_', $property )
    );
}


/**
 * Prepare og meta data.
 *
 * @param array $book
 *   Array containing book data.
 *
 */
//  @todo: Needs to be reviewed after re-structure of 'bookcrossing_history' table
function bookcrossing_meta_og($book)
{
    bookcrossing_meta_og_add('fb:app_id', variable_get('fboauth_id', '') );
    bookcrossing_meta_og_add('og:type', 'book' );
    bookcrossing_meta_og_add('og:url', url('book/' . $book['bid'], array('absolute' => TRUE)) );
    bookcrossing_meta_og_add('og:title', $book['node']->title);
    bookcrossing_meta_og_add('og:description',
        field_get_items('node', $book['node'], 'field_bookcrossing_description', $book['node']->language)[0]['value']
    );

    bookcrossing_meta_og_add(
        'og:image', 
        (field_get_items('node', $book['node'], 'field_bookcrossing_image', $book['node']->language) != NULL) ? file_create_url( field_get_items('node', $book['node'], 'field_bookcrossing_image', $book['node']->language)[0]['uri']) : file_create_url('public://no-image/' . $book['color'] . '.jpg') 
    );

    if ( field_get_items('node', $book['node'], 'field_bookcrossing_author', $book['node']->language) != NULL ) {
        $i = 0;
        foreach ( field_get_items('node', $book['node'], 'field_bookcrossing_author', $book['node']->language) as $tid )
            bookcrossing_meta_og_add('book:author', taxonomy_term_load($tid['tid'])->name, $i++);
    }

    bookcrossing_meta_og_add('book:release_date', isset($book['time_left']) ? $book['time_left'] : '');
    bookcrossing_meta_og_add('book:isbn', ( field_get_items('node', $book['node'], 'field_bookcrossing_isbn', $book['node']->language) != NULL ) ? field_get_items('node', $book['node'], 'field_bookcrossing_isbn', $book['node']->language)[0]['safe_value'] : '');

    if ( field_get_items('node', $book['node'], 'field_bookcrossing_genre', $book['node']->language) != NULL ) {
        $i = 0;
        foreach ( field_get_items('node', $book['node'], 'field_bookcrossing_genre', $book['node']->language) as $tid )
            bookcrossing_meta_og_add('book:tag', taxonomy_term_load($tid['tid'])->name, $i++);
    }
}


/**
 * Returns item list with the status of the book.
 *
 * @param array $book
 *   array containing book data.
 *
 * @return string
 *   html output of the current status
 *
 */
function bookcrossing_book_status($book = array(), $show_safezones = FALSE)
{
    try {
        switch ($book['history'][BOOKCROSSING_CURRENT]['event_type'])
        {
            case BOOKCROSSING_BOOK_STATUS_FREE:
                $status_string = t('Travelling');
                $items = array( '<div class="status-label">' . t('Book status') . ':</div>' . $status_string );
                $parents = taxonomy_get_parents_all($book['history'][BOOKCROSSING_CURRENT]['place']->tid);
                $levels = array('place', 'sort', 'country');
                for ($i=0; $i<3; $i++)
                {
                    if( isset($parents[$i]) )
                    {
                        $place_output[] = l($parents[$i]->name, 'books/place', array( 'query' => array($levels[$i] => $parents[$i]->name) ));
                    }
                    else
                        break;
                }
                if ($place_output) {
                    $place_output = array_reverse($place_output);
                    $items[] = '<div class="status-label">' . t('Place') . ':</div>' . implode(', ', $place_output); //$book['place']->name;    
                }
            break;
            case BOOKCROSSING_BOOK_STATUS_FOUND:
                $status_string = t('Found');
                $items = array( '<div class="status-label">' . t('Book status') . ':</div>' . $status_string );
                if ($user_profile = bookcrossing_get_social_profile($book['history'][BOOKCROSSING_CURRENT]['user'])) {
                    $user_link = l($book['user']->name, $user_profile['profileURL'], array('html' => TRUE, 'attributes' => array('target' => '_blank')));
                } else {
                    $user_link = l($book['history'][BOOKCROSSING_CURRENT]['user']->name, 'user/' . $book['history'][BOOKCROSSING_CURRENT]['user']->uid);
                }
                $items[] = '<div class="status-label">' . t('Reader') . ':</div>' . $user_link;
            break;
            case BOOKCROSSING_BOOK_STATUS_RESERVED:
                $status_string = t('Reserved');
                $items = array( '<div class="status-label">' . t('Book status') . ':</div>' . $status_string );
            break;
            default:
            break;
        }
    
        $places = theme('item_list', array('items' => $items, 'type' => 'ul', 'attributes' => array('class' => 'status-info')));
    /*
     * Show self zones
     * */
        $safezones = '';
        if($show_safezones) {
            $items = array();
            $zones_output = array();
            $query = db_select('field_data_field_places', 'f')->distinct()
                    ->fields('place', array('tid', 'name'));
            $query->innerJoin('taxonomy_term_data', 'place', 'place.tid = f.entity_id');
            $terms =  $query->condition('f.field_places_tid', $book['history'][BOOKCROSSING_CURRENT]['place']->tid)->execute()->fetchAllKeyed();
            foreach($terms as $tid => $term) {
                $zones_output[] = l($term, 'taxonomy/term/' . $tid);
            }
            $items[] = '<div class="status-label">' . t('Safe zones') . ':</div>' . implode(', ', $zones_output);
            $safezones = theme('item_list', array('items' => $items, 'type' => 'ul', 'attributes' => array('class' => 'status-info')));
        }    
    }

    catch (Exception $e) {
        watchdog($e->getMessage(), WATCHDOG_NOTICE);
    }

    return $places . $safezones;
}


/**
 * Loads history of the book.
 *
 * @return array
 *   array with the places and current status
 *
 *   array(
 *     'places' => array(
 *        array('place 1'),
 *        array('place 2'),
 *        ...
 *      ),
 *     'user' => 'current reader',
 *     'place' => 'current place',
 *     'comment' => 'comment of the logged user',
 *     'status' => 'current status of the book',
 *     'node' => 'book class',
 *   )
 *
 */
//  @todo: !Important! This fuction needs to be refactored after re-structure of 'bookcrossing_history' table
function bookcrossing_history_load($bid = '', $pager = TRUE)
{
    if (!$bid) {
        watchdog('bookcrossing.module', 'Invalid book id was passed to bookcrossing_history_load() function.', WATCHDOG_NOTICE);
        return '';
    }
    $pager_limit = variable_get('bookcrossing_history_pager_limit', 5);

    $query = db_select('bookcrossing_books', 'book');
    // Adding pager
    if ($pager && $pager_limit !== FALSE) {
        $query = $query->extend('PagerDefault')->limit($pager_limit);
    }
    $query->innerJoin('bookcrossing_history', 'history', 'book.bid = history.book_id');
    $query->leftJoin('bookcrossing_comment', 'comment', 'book.bid = comment.bid');
    $query
        ->fields('book', array('bid', 'bcid', 'nid', 'status', 'color'))
        ->fields('history', array('user_id', 'place_id', 'event_type', 'date_time'))
        ->fields('comment', array('comment'))
        ->condition('book.bid', $bid, '=')
        ->orderBy('date_time', 'DESC');

    $states = $query->execute()->fetchAll();
//    $states[] = $query->execute()->fetch(PDO::FETCH_ASSOC);

    $book = array();

    // Creating array of places where book was.
    foreach ($states as $state)
    {
        $book['history'][] = array(
            'user' => user_load($state->user_id),
            'place' => taxonomy_term_load($state->place_id),
            'date_time' => $state->date_time,
            'event_type' => $state->event_type,
            'comment' => $state->comment,
        );
    }
    // Get general info from the latest history record. It should be [0] element, since we are sorting DESC.
    $book['node'] = node_load($states[BOOKCROSSING_CURRENT]->nid);
    $book['color'] = $states[BOOKCROSSING_CURRENT]->color;
    $book['bid'] = $bid;

    return $book;
}


/**
 * Adding default image if book doesnt have it and chage links for author, title and genre.
 *
 * @param array $view
 *   array in the format for render()
 *
 * @param array $book
 *   array with book information
 *
 * @param $show_info
 *   show info about author and year in the image
 *
 * @return array
 *   changed array for render()
 *
 * @todo: Process the case when cover image is not found and use default image for that
 */
function bookcrossing_prepare_book_view($view, $book, $show_info = TRUE)
{
    // change link for image and provide default if there is no image
    if (!isset($view['field_bookcrossing_image'][0])) {
        $style = $book['color'] ? ' style="background-color: #' . $book['color'] . ';"' : '';
        $markup = '<div class="book-no-image"><div' . $style . ' class="book-no-image-container cl-'. $book['color'] .'"><a href="' . url('book/' . $book['bid'], array('absolute' => TRUE)) . '">';

        if ($show_info) {
            $markup .= '<div class="book-no-image-title">' . $book['node']->title . '</div>';
            if (isset($book['node']->field_bookcrossing_year[LANGUAGE_NONE])) {
                $markup .= '<div class="book-no-image-year">' . $book['node']->field_bookcrossing_year[LANGUAGE_NONE][0]['value'] . '</div>';
            }
        }

        $markup .= '</a></div></div>';

        $view['field_bookcrossing_image'] = array(
            '#markup' => $markup,
        );
    } else {
        if (isset($view['field_bookcrossing_image'][0]['#path']['path'])) {
            $view['field_bookcrossing_image'][0]['#path']['path'] = url('book/' . $book['bid'], array('absolute' => TRUE));
        }
    }

    // change link for author
    if (isset($view['field_bookcrossing_author'])) {
        foreach (element_children($view['field_bookcrossing_author']) as $child) {
            if (isset($view['field_bookcrossing_author'][$child]['#href'])) {
                $view['field_bookcrossing_author'][$child]['#href'] = url('books/author', array('query' => array('sort' => $view['field_bookcrossing_author'][$child]['#title']), 'absolute' => TRUE));
            }
        }
    }

    // change link for genre
    if (isset($view['field_bookcrossing_genre'])) {
        foreach (element_children($view['field_bookcrossing_genre']) as $child) {
            if (isset($view['field_bookcrossing_genre'][$child]['#href'])) {
                $view['field_bookcrossing_genre'][$child]['#href'] = url('books/genre', array('query' => array('sort' => $view['field_bookcrossing_genre'][$child]['#title']), 'absolute' => TRUE));
            }
        }
    }

    // change link for title
    if (isset($view['title'])) {
        if (strstr($view['title'][0]['#markup'], '</a>')) {
            $view['title'][0]['#markup'] = '<h2 class="node-title">' . l($book['node']->title, 'book/' . $book['bid']) . '</h2>';
        }
    }

    return $view;
}


/**
 * Form for adding comment for a book.
 *
 * @param array $book
 *   book information
 *
 */
function bookcrossing_book_comment($form, $form_state, $book = array())
{
    global $user;
    $form = array();
    $form_state['book'] = $book;

    // Form for selecting place for a book
    bookcrossing_select_place($form, $form_state);

    $form['place']['#title'] = $book['status'] ? t('Where have you left the book?') : t('Where have you found the book?');

    // Check if user already added a comment
    $exists = db_select('bookcrossing_comment', 'comment')
        ->fields('comment', array('comment'))
        ->condition('uid', $user->uid, '=')
        ->condition('bid', $book['bid'], '=')
        ->execute()
        ->fetchField();

    if ($book['status'] && !$exists) {
        $form['comment'] = array(
            '#type' => 'textarea',
            '#title' => t('Write few words about the book'),
        );
    }

    if ($exists) {
        $form['comment'] = array(
            '#type' => 'hidden',
            '#value' => $exists,
        );
    }

    $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Save'),
    );

//           city = info[1].replace(/^\s+|\s+$/g,'');
//           country = info[0].replace(/^\s+|\s+$/g,'');

    return $form;
}

/**
 * Submit for adding comment for a book form.
 *
 */
function bookcrossing_book_comment_submit($form, $form_state)
{
    global $user;
    $book = $form_state['build_info']['args'][0];

    if ($form_state['values']['create-or-select'] == 'my-place') {
        $place_id = $form_state['values']['my-places-list'];
    } elseif ($form_state['values']['create-or-select'] == 'create-new') {
        /**
         * Saving new place
         *
         */

        // Check user input
        $new_place = filter_xss($form_state['values']['new-place'], array());

        $query = db_select('taxonomy_term_data', 'term');
        $query->innerJoin('taxonomy_term_hierarchy', 'term_tree', 'term.tid = term_tree.tid');
        $isset = $query->fields('term', array('tid'))
            ->condition('term.name', $new_place, '=')
            ->condition('term.vid', BOOKCROSSING_PLACES_VID, '=')
            ->condition('term_tree.parent', $form_state['values']['city'], '=')
            ->execute()
            ->fetchField();

        if (!$isset) {
            $term = new stdClass();
            $term->vid = BOOKCROSSING_PLACES_VID;
            $term->name = $new_place;
            $term->parent = $form_state['values']['city'];

            taxonomy_term_save($term);

            $place_id = $term->tid;
        }
        else
        {
            $place_id = $isset;
        }

        global $user;
        $my_place = db_select('bookcrossing_places', 'place')
            ->fields('place', array('uid'))
            ->condition('tid', $place_id, '=')
            ->condition('uid', $user->uid, '=')
            ->execute()
            ->fetchField();

        if (!$my_place) {
            db_insert('bookcrossing_places')
                ->fields(array('uid' => $user->uid, 'tid' => $place_id))
                ->execute();
        }
    }

    if ($book['status'] == BOOKCROSSING_BOOK_STATUS_FOUND) {
        // Add info where book left
        db_update('bookcrossing_history')
            ->fields(array(
                    'date_time' => REQUEST_TIME,
                    'place_id' => $place_id,
                )
            )
            ->condition('book_id', $book['bid'], '=')
            ->condition('date_time', 0, '=')
            ->execute();

        // Add comment to a book
        if (isset($form_state['values']['comment'])) {
            $comment = strip_tags(filter_xss($form_state['values']['comment']));
            db_insert('bookcrossing_comment')
                ->fields(array('bid' => $book['bid'], 'uid' => $user->uid, 'comment' => $comment))
                ->execute();
        }

        // Update information about the book
        db_update('bookcrossing_books')
            ->fields(array('owner' => -1, 'status' => BOOKCROSSING_BOOK_STATUS_FREE, 'current_place' => $place_id))
            ->condition('bid', $book['bid'])
            ->execute();
    }
    elseif ($form_state['build_info']['args'][0]['status'] == BOOKCROSSING_BOOK_STATUS_FREE) {
        // new entry for book history
        db_insert('bookcrossing_history')
            ->fields(array(
                    'book_id' => $form_state['build_info']['args'][0]['bid'],
                    'user_id' => $user->uid,
                    'place_id' => $place_id,
                    'event_type' => BOOKCROSSING_BOOK_STATUS_FOUND,
                    'date_time' => REQUEST_TIME,
                )
            )
            ->execute();

        // Update book information
        db_update('bookcrossing_books')
            ->fields(array('owner' => $user->uid, 'status' => BOOKCROSSING_BOOK_STATUS_FOUND, 'current_place' => 0))
            ->condition('bid', $book['bid'])
            ->execute();
    }

    drupal_goto('book/' . $book['bid']);
}

/**
 * Helper function: return terms list in format expected by form item.
 *
 * @param array $terms
 *   array of therms
 *
 * @return array
 *   array for form #options property
 *
 */
function bookcrossing_terms_to_options($terms = array())
{
    if (empty($terms)) {
        return array();
    }

    foreach ($terms as $term) {
        $options[$term->tid] = $term->name;
    }

    return $options;
}

/**
 * Form part for selecting place.
 *
 */
function bookcrossing_select_place(&$form, $form_state)
{
    $form['#validate'][] = 'bookcrossing_validate_place';

    $form['place'] = array(
        '#type' => 'fieldset',
        '#title' => t('Place where you want to leave the book'),
    );

    $countries = taxonomy_get_tree(3, 0, 1);
    $countries = bookcrossing_terms_to_options($countries);

    $selected_country = isset($form_state['values']['country']) ? $form_state['values']['country'] : '';

    if ($selected_country) {
        $terms = taxonomy_get_tree(3, $selected_country, 1);
    } else {
        reset($countries);
        $terms = taxonomy_get_tree(3, key($countries), 1);
    }

    $cities = bookcrossing_terms_to_options($terms);

    global $user;
    $place_options = array();
    $user_places = bookcrossing_user_places($user->uid);
    $places = taxonomy_term_load_multiple($user_places);
    $place_options['no-place'] = t('Select a place');

    foreach ($places as $p) {
        $place_options[$p->tid] = $p->name;
    }

    $output = array();
    $terms = taxonomy_get_parents_all(key($place_options));
    foreach ($terms as $term) {
        $output[] = $term->name;
    }

    unset($output[0]);
    $output = array_reverse($output);
    $place_description = !empty($output) ? '(' . implode(', ', $output) . ')' : '';

    // $form['place']['or'] = array(
    //     '#markup' => '<div class="place-or">' . t('or') . '</div>',
    // );

    $form['place']['create-or-select'] = array(
        '#type' => 'radios',
        '#options' => array(
            'my-place' => t('Select your place'),
            'create-new' => t('Create new place'),
        ),
        '#default_value' => 'my-place',
    );

    $form['place']['my-places-list'] = array(
        '#prefix' => '<div class="my-places-list-wrapper">',
        '#suffix' => '<div id="my-places-list-description">' . $place_description . '</div></div>',
        '#type' => 'select',
        '#options' => $place_options,
        '#default_value' => isset($form_state['values']['my-places-list']) ? $form_state['values']['my-places-list'] : key($place_options),
        '#ajax' => array(
            'callback' => 'bookcrossing_place_description',
        ),
        '#states' => array(
            'visible' => array(
                ':input[name="create-or-select"]' => array('value' => 'my-place'),
            ),
        ),
    );

    $form['place']['country'] = array(
        '#type' => 'select',
        '#title' => t('Country'),
        '#options' => $countries,
        '#ajax' => array(
            'wrapper' => 'cities-wrapper',
            'callback' => 'bookcrossing_get_cities',
        ),
        '#states' => array(
            'visible' => array(
                ':input[name="create-or-select"]' => array('value' => 'create-new'),
            ),
        ),
    );

    $selected_city = isset($form_state['values']['city']) ? $form_state['values']['city'] : key($cities);
    $form['place']['city'] = array(
        '#type' => 'select',
        '#title' => t('City'),
        '#options' => $cities,
        '#prefix' => '<div id="cities-wrapper">',
        '#suffix' => '</div>',
        '#default_value' => $selected_city,
        '#states' => array(
            'visible' => array(
                ':input[name="create-or-select"]' => array('value' => 'create-new'),
            ),
        ),
        '#ajax' => array(
            'callback' => 'bookcrossing_change_autocomplete_path',
            'wrapper' => 'new-place-input',
        ),
    );

    $form['place']['new-place'] = array(
        '#type' => 'textfield',
        '#prefix' => '<div id="new-place-input">',
        '#suffix' => '</div>',
        '#autocomplete_path' => 'ajax/bookcrossing-places-autocompletion/' . $selected_city,
        '#title' => t('New place'),
        '#description' => '', //t('Enter the place where u want to leave the book.'),
        '#states' => array(
            'visible' => array(
                ':input[name="create-or-select"]' => array('value' => 'create-new'),
            ),
        ),
    );
}

function bookcrossing_validate_place($form, $form_state)
{

    $place = filter_xss($form_state['values']['new-place'], array());


    if ($form_state['values']['my-places-list'] == 'no-place' && empty($place)) {

        form_set_error('place', t('Please select place from a list or create new'));

        return FALSE;

    }


    return TRUE;

}


function bookcrossing_change_autocomplete_path($form, $form_state)
{

    return $form['place']['new-place'];

}


/**
 * Loads place description
 */
function bookcrossing_place_description($form, $form_state)
{
    $commands = array();

    $output = array();
    $terms = taxonomy_get_parents_all($form_state['values']['my-places-list']);
    foreach ($terms as $term) {
        $output[] = $term->name;
    }

    unset($output[0]);
    $output = array_reverse($output);
    $description = !empty($output) ? '(' . implode(', ', $output) . ')' : '';

    $commands[] = ajax_command_html('#my-places-list-description', $description);
    return array('#type' => 'ajax', '#commands' => $commands);
}


/**
 * Load user places
 */

function bookcrossing_user_places($uid = '')
{
    $query = db_select('bookcrossing_places', 'p');
    $query->innerJoin('taxonomy_term_data', 't', 'p.tid = t.tid');
    $query->fields('p', array('tid'));
    $query->condition('p.uid', $uid, '=');
    $tids = $query->execute()->fetchCol();

    return $tids;
}


/**
 * Ajax callback: refresh city list.
 */

function bookcrossing_get_cities($form, $form_state)
{
    return $form['place']['city'];
}


/**
 * Ajax callback: refresh places list.
 */
function bookcrossing_get_places($form, $form_state)
{
    return $form['place']['radios'];
}


/**
 * Load a information about book.
 *
 * @param int bid
 *   book id
 *
 * @return array
 *   array containing book data
 * @return FALSE
 *   in case book not found
 *
 *   array(
 *      'bid' => 'book id',
 *      'bcid' => 'bookcrossing id',
 *      'nid' => 'node assosiated with this book',
 *      'status' => 'book status (free, found)',
 *      'owner' => 'current reader of the book',
 *      'current_place' => '',
 *      'color' => 'randomly generated HEX-coded color for book cover',
 *      'place_id_left' => 'id of place where user released the book',
 *      'time_left' => 'timestamp when book was released by user',
 *      'found' => 'timestamp when book was found',
 *      'user' => object('last or current reader of the book'),
 *      'node' => object('book class data'),
 *      'place' => object('current or last place of the book'),
 *   )
 */
//  @todo: Move $conf['bookcrossing_default_user_id'] and $conf['bookcrossing_default_place_id'] to module settings
//  @todo: Array $book needs to be refactored after re-structure of 'bookcrossing_history' table
function bookcrossing_load($bid = '')
{
    $book = array();

    if ($bid) {
        $query = db_select('bookcrossing_books', 'book');
        $query->innerJoin('bookcrossing_history', 'history', 'book.bid = history.book_id');
        $states = $query->fields('book', array('bid', 'bcid', 'nid', 'status', 'owner', 'color'))
            ->fields('history', array('user_id', 'place_id', 'event_type', 'date_time'))
            ->condition('book.bid', $bid, '=')
            ->orderBy('date_time', 'DESC')
            ->range(0, 1)
            ->execute();
        $book = $states->fetch(PDO::FETCH_ASSOC);

        if ($book) {
            $book['user'] = user_load($book['user_id']);
            unset($book['user_id']);

            $book['node'] = node_load($book['nid']);

            $book['place'] = taxonomy_term_load($book['place_id']);
            unset($book['place_id']);
        }
        else {
            $book = db_select('bookcrossing_books', 'book')
                ->fields('book')
                ->condition('bid', $bid, '=')
                ->execute()
                ->fetchAssoc();
            if($book) {
                global $conf;

                watchdog('bookcrossing.module', 'Discrepancy between "bookcrossing_books" and "bookcrossing_history" data tables queried in function: bookcrossing_load($bid). Book with bid=%bid not found in "bookcrossing_history".', array('%bid' => $bid), WATCHDOG_ERROR);
                $book['place_id'] = $book['current_place'];
                unset($book['current_place']);
                $book['date_time'] = REQUEST_TIME;
                $book['user'] = user_load(isset($conf['bookcrossing_default_user_id']) ? $conf['bookcrossing_default_user_id'] : 0);
                $book['node'] = node_load($book['nid']);
                $book['place'] = taxonomy_term_load(isset($conf['bookcrossing_default_place_id']) ? $conf['bookcrossing_default_place_id'] : 0);
                
                return $book;
            }
            else {
                watchdog('bookcrossing.module', 'Book with bid=%bid was not found in "bookcrossing_books" data table. Executed function: bookcrossing_load($bid).', array('%bid' => $bid), WATCHDOG_ERROR);

                return FALSE;
            }
        }
    }

    return $book;
}


/**
 * Load a information about book.
 *
 * @param int bid
 *   book id
 *
 * @return array
 *   the same array as bookcrossing_load() returns.
 *
 * @see bookcrossing_load().
 */
function bookcrossing_load_by_bcid($bcid = '')
{
    $book = array();
    if ($bcid) {
        $bid = db_select('bookcrossing_books', 'book')
            ->fields('book', array('bid'))
            ->condition('bcid', $bcid, '=')
            ->execute()
            ->fetchField();
        $book = bookcrossing_load($bid);
        if ($book) {
            $book['node'] = node_load($book['nid']);
        }
    }
    return $book;
}

/**
 * Loads multiple books at one time.
 *
 * @param array $bids
 *   array book ids to load
 *
 * @return array
 *   array of the needed books
 */
//  @todo: Fuction needs to be refactored after 'bookcrossing_history' re-structuring
function bookcrossing_load_multiple($bids = array())
{
    $books = array();

    if ($bids) {
        $query = db_select('bookcrossing_books', 'book');
        $query->innerJoin('bookcrossing_history', 'history', 'book.bid = history.book_id');
        $states = $query->fields('book', array('bid', 'bcid', 'nid', 'status', 'owner', 'color'))
            ->fields('history', array('user_id', 'place_id', 'event_type', 'date_time'))
            ->condition('book.bid', $bids, 'IN')
            ->execute();
        $states = $states->fetchAllAssoc('bid');

        $nids = array();
        $tids = array();
        $uids = array();

        // Creating array of entity ids for loading multiple in one time.
        foreach ($states as $state) {
            $tids[$state->place_id] = $state->place_id;
            $uids[$state->user_id] = $state->user_id;
            $nids[$state->nid] = $state->nid;
        }

        // Loading needed entities.
        $places = taxonomy_term_load_multiple($tids);
        $users = user_load_multiple($uids);
        $nodes = node_load_multiple($nids);

        // Creating array of books
        foreach ($states as $state) {
            $book = (array)$state;
            $book['user'] = $users[$state->user_id];
            $book['node'] = $nodes[$state->nid];
            $book['place'] = $places[$state->place_id];
            $books[] = $book;
        }
    }

    return $books;
}


/**
 * Form for releasing the book.
 */
function bookcrossing_release_book_form($form, $form_state)
{
    $form['pre-existed-book'] = array(
        '#markup' => '<div class="bcid-pretext">' . t('If you releasing a book you have found earlier, please find its BCID (e.g. ABCD-1234) that written on a book and insert it into fields below.') . '</div>',
    );

    $form['existed-book'] = array(
        '#type' => 'fieldset',
        '#title' => t('Release book (already has BCID)'),
        '#tree' => TRUE,
    );

    $form['existed-book']['bcid-first-part'] = array(
        '#type' => 'textfield',
        '#size' => 5,
    );

    $form['existed-book']['bcid-second-part'] = array(
        '#type' => 'textfield',
        '#prefix' => '<div class="bcid-separator">-</div>',
        '#size' => 10,
    );

    $form['existed-book']['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Release'),
        '#submit' => array(
            'bookcrossing_release_book_form_submit',
        ),
    );

    $form['existed-book']['description'] = array(
        '#markup' => '<p class="help-block">' . t('Enter BCID of book you want to release') . '</p>',
    );

    $form['pre-add-new'] = array(
        '#markup' => '<div class="clearfix" style="height:50px;"></div><div class="bcid-pretext">' . t('To release a new book that is not in catalog yet, please click the button below. After you fill all nessary fields, you will get a new BCID, that should be written on a new book to track its journey.') . '</div>',
    );

    $form['add-new'] = array(
        '#type' => 'fieldset',
        '#title' => t('Register new book (has no BCID yet)'),
        '#tree' => TRUE,
    );

    $form['add-new']['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Add new book'),
        '#submit' => array(
            'bookcrossing_add_new_book',
        ),
    );

    return $form;
}


/**
 * Form submit: release book by its BCID.
 */
function bookcrossing_release_book_form_submit($form, $form_state)
{
    $bcid = $form_state['values']['existed-book']['bcid-first-part'] . '-' . $form_state['values']['existed-book']['bcid-second-part'];
    $book = bookcrossing_load_by_bcid($bcid);
    $error = FALSE;

    global $user;
    $reserved = db_select('bookcrossing_books', 'b')
        ->fields('b', array('bcid'))
        ->condition('bcid', $bcid, '=')
        ->condition('owner', $user->uid, '=')
        ->condition('status', BOOKCROSSING_BOOK_STATUS_RESERVED, '=')
        ->execute()
        ->fetchField();

    if (!$book && !$reserved) {
        drupal_set_message(t('There is no book with that BCID.'));
        $error = TRUE;
    }

    /**
     * Book is already released.
     */
    if (isset($book['status']) && !$book['status']) {
        drupal_set_message(t('Cannot to release book because its already was released.'));
        $error = TRUE;
    }

    /**
     * Can only release books user reading.
     */
    if (isset($book['user']->uid) && $book['user']->uid != $user->uid) {
        drupal_set_message(t('You cannot release this book because u are not reading it now.'));
        $error = TRUE;
    }

    if ($reserved && !$error) {
        drupal_goto('add-reserved-book/' . $bcid);
    } elseif (!$error) {
        drupal_goto('release-book/' . $book['bid']);
    }
}


/**
 * Form submit: go to page for adding new book.
 */
function bookcrossing_add_new_book($form, $form_state)
{
    drupal_goto('release-book/add-new');
}


/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Adding wrappers for form elements to reload them via ajax.
 */
function bookcrossing_form_bookcrossing_node_form_alter(&$form, &$form_state, $info)
{
    if (!isset($form_state['build_info']['args'][1])) {
        return;
    }
    /**
     @todo check if javascript is enabled
     */
    unset($form_state['values']['field_bookcrossing_image']);

// Do not update bcid on node update.
//  if (arg(2) != 'edit') {
//    $form['actions']['submit']['#submit'][] = 'bookcrossing_add_book';
//  }

    $bcid = isset($form_state['build_info']['args'][1]) ? $form_state['build_info']['args'][1] : 0;
    if ($bcid !== 0 && $bcid != 'add-new-book') {
        $form['bcid'] = array(
            '#type' => 'value',
            '#value' => $bcid,
        );
        $form['actions']['submit']['#submit'][] = 'bookcrossing_add_reserved_book';
    } elseif ($bcid == 'add-new-book') {
        $form['actions']['submit']['#submit'][] = 'bookcrossing_add_book';
    }
    $title = isset($form_state['values']['title']) ? $form_state['values']['title'] : '';

    if ($title) {
        $nid = db_select('node', 'n')->fields('n', array('nid'))->condition('title', $title, '=')->execute()->fetchField();
        $node = $nid != '' ? node_load($nid) : array();

        /**
         * If we have that book class already, provide default values.
         */
        if (!empty($node)) {
            if (!$form['nid']['#value']) {
                $form['nid']['#value'] = $node->nid;
            }
            $authors = bookcrossing_default_value_for_terms($node->field_bookcrossing_author[LANGUAGE_NONE]);
            $form['field_bookcrossing_author'][LANGUAGE_NONE]['#value'] = $authors;
            $form['field_bookcrossing_author'][LANGUAGE_NONE]['#disabled'] = TRUE;

            $genres = bookcrossing_default_value_for_terms($node->field_bookcrossing_genre[LANGUAGE_NONE]);
            $form['field_bookcrossing_genre'][LANGUAGE_NONE]['#value'] = $genres;
            $form['field_bookcrossing_genre'][LANGUAGE_NONE]['#disabled'] = TRUE;

            if (isset($node->field_bookcrossing_isbn[LANGUAGE_NONE])) {
                $form['field_bookcrossing_isbn'][LANGUAGE_NONE][0]['value']['#value'] = $node->field_bookcrossing_isbn[LANGUAGE_NONE][0]['safe_value'];
                $form['field_bookcrossing_isbn'][LANGUAGE_NONE][0]['value']['#disabled'] = TRUE;
            }

            $form['field_bookcrossing_description'][LANGUAGE_NONE][0]['value']['#value'] = $node->field_bookcrossing_description[LANGUAGE_NONE][0]['safe_value'];
            $form['field_bookcrossing_description'][LANGUAGE_NONE][0]['value']['#disabled'] = TRUE;

            if (isset($node->field_bookcrossing_image[LANGUAGE_NONE])) {
                $form['field_bookcrossing_image'][LANGUAGE_NONE][0]['#default_value'] = $node->field_bookcrossing_image[LANGUAGE_NONE][0];
                $form['field_bookcrossing_image'][LANGUAGE_NONE][0]['#disabled'] = TRUE;
            }

            if (isset($node->field_bookcrossing_cover[LANGUAGE_NONE])) {
                $form['field_bookcrossing_cover'][LANGUAGE_NONE]['#value'] = $node->field_bookcrossing_cover[LANGUAGE_NONE][0]['value'];
                $form['field_bookcrossing_cover'][LANGUAGE_NONE]['#disabled'] = TRUE;
            }

            if (isset($node->field_bookcrossing_year[LANGUAGE_NONE])) {
                $form['field_bookcrossing_year'][LANGUAGE_NONE][0]['value']['#value'] = $node->field_bookcrossing_year[LANGUAGE_NONE][0]['value'];
                $form['field_bookcrossing_year'][LANGUAGE_NONE][0]['value']['#disabled'] = TRUE;
            }

            $form['#validate'] = array();

            if ($bcid === 'add-new-book') {
                $form['actions']['submit']['#submit'] = array('bookcrossing_add_book');
            } elseif ($bcid !== 0) {
                $form['actions']['submit']['#submit'] = array('bookcrossing_add_reserved_book');
            }
        }
    };

    $form['title']['#ajax'] = array(
        'callback' => 'bookcrossing_autocomplete_form',
        'event' => 'blur',
    );

    $form['field_bookcrossing_isbn']['#prefix'] = '<div id="bookcrossing-first-part">';
    $form['field_bookcrossing_genre']['#suffix'] = '</div>';

    $form['field_bookcrossing_description']['#prefix'] = '<div id="bookcrossing-second-part">';
    $form['field_bookcrossing_year']['#suffix'] = '</div>';

    //form for selecting book place
    bookcrossing_select_place($form, $form_state);
    $form['place']['#weight'] = 7.5; //3.5
    $form['actions']['submit']['#submit'][] = 'bookcrossing_save_place';
    $form['actions']['submit']['#submit'][] = 'bookcrossing_redirect';
}


/**
 * Implements hook_node_delete().
 */
function bookcrossing_node_delete($node)
{
    if ($node->type == 'bookcrossing') {
        $bids = db_select('bookcrossing_books', 'book')
            ->fields('book', array('bid'))
            ->condition('nid', $node->nid, '=')
            ->execute()
            ->fetchCol();

        if (empty($bids)) {
            return;
        }

        db_delete('bookcrossing_books')
            ->condition('nid', $node->nid, '=')
            ->execute();

        db_delete('bookcrossing_history')
            ->condition('book_id', $bids, 'IN')
            ->execute();

        db_delete('bookcrossing_comment')
            ->condition('bid', $bids, 'IN')
            ->execute();

        db_delete('bookcrossing_favourites')
            ->condition('bid', $bids, 'IN')
            ->execute();
    }
}


/**
 * Form submit: redirect to book added page.
 */
function bookcrossing_redirect($form, $form_state)
{
    $_SESSION['added-new-book'] = TRUE;
    drupal_goto('book-added/' . $form_state['bcid']);
}


/**
 * Form submit: save place for a book.
 */
function bookcrossing_save_place($form, $form_state)
{
    $bid = db_select('bookcrossing_books', 'book')
        ->fields('book', array('bid'))
        ->condition('bcid', $form_state['bcid'], '=')
        ->execute()
        ->fetchField();

    if ($form_state['values']['create-or-select'] == 'my-place') {
        $place_id = $form_state['values']['my-places-list'];
    } elseif ($form_state['values']['create-or-select'] == 'create-new') {

        /**
         * Saving new place
         */

        // check user input
        $new_place = filter_xss($form_state['values']['new-place'], array());

        $query = db_select('taxonomy_term_data', 't');
        $query->innerJoin('taxonomy_term_hierarchy', 'h', 't.tid = h.tid');

        $isset = $query->fields('t', array('tid'))
            ->condition('t.name', $new_place, '=')
            ->condition('t.vid', BOOKCROSSING_PLACES_VID, '=')
            ->condition('h.parent', $form_state['values']['city'], '=')
            ->execute()
            ->fetchField();

        if (!$isset) {
            $term = new stdClass();
            $term->vid = 3;
            $term->name = $new_place;
            $term->parent = $form_state['values']['city'];

            taxonomy_term_save($term);

            $place_id = $term->tid;
        } else {
            $place_id = $isset;
        }

        global $user;
        $my_place = db_select('bookcrossing_places', 'p')
            ->fields('p', array('uid'))
            ->condition('tid', $place_id, '=')
            ->condition('uid', $user->uid, '=')
            ->execute()
            ->fetchField();

        if (!$my_place) {
            db_insert('bookcrossing_places')
                ->fields(array('uid' => $user->uid, 'tid' => $place_id))
                ->execute();
        }
    }

    // new entry for books history
    db_insert('bookcrossing_history')
        ->fields(array(
                'user_id' => $form_state['values']['uid'],
                'book_id' => $bid,
                'date_time' => REQUEST_TIME,
                'place_id' => $place_id,
                'event_type' => BOOKCROSSING_BOOK_STATUS_FREE
            )
        )
        ->execute();

    // update book information
    db_update('bookcrossing_books')
        ->fields(array(
                    'current_place' => $place_id,
                    )
                )
        ->condition('bid', $bid, '=')
        ->execute();
}


/**
 * Helper function: returns string from terms values.
 *
 * @param array $terms_array
 *   array of terms
 *
 * @return string
 *   string of default value
 *
 */
function bookcrossing_default_value_for_terms($terms_array = array())
{
    if (empty($terms_array)) {
        return '';
    }

    $tids = array();
    foreach ($terms_array as $tid) {
        $tids[] = $tid['tid'];
    }

    $names = array();
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $term) {
        $names[] = $term->name;
    }

    return implode(',', $names);
}


/**
 * Form submit for book adding form: save bcid of the book.
 *
 */
function bookcrossing_add_book($form, &$form_state)
{
    $bcid = new Bcid(); ///bookcrossing_generate_bcid();
    $form_state['bcid'] = $bcid->getBcid();

    // always add cover color for a book, even if cover image exists
    $color = bookcrossing_generate_color();

    // $color = 0;
    // if ($form_state['values']['field_bookcrossing_image'][LANGUAGE_NONE][0]['fid'] == 0) {
    //     $color = bookcrossing_generate_color();
    // }

    // Adding new book
    db_insert('bookcrossing_books')->fields(array('current_place' => 0, 'bcid' => $bcid, 'nid' => $form_state['values']['nid'], 'color' => $color))->execute();

    $book = array();
    $book['bid'] = db_select('bookcrossing_books', 'book')
        ->fields('book', array('bid'))
        ->condition('book.bcid', $bcid, '=')
        ->execute()->fetchField();
    $book['node'] = node_load($form_state['values']['nid']);
    module_load_include('inc', 'pathauto', 'pathauto');
    // @todo: Human-readable name should be generated when book is resleased. Now it throws an error.
    // pathauto_create_alias('bookcrossing', 'insert', 'book/' . $book['bid'], array('book' => $book));
}


function bookcrossing_generate_color()
{
    $colors = array('bb2c26', '436936', '5b80ad', '5c606b', 'e23263', '693e2b', 'f2c747');
    return $colors[mt_rand(0, count($colors) - 1)];
}

function bookcrossing_node_presave($node) {
    //check ISBN
    if ($node->type == 'bookcrossing' && isset($node->field_bookcrossing_isbn[LANGUAGE_NONE][0]['value'])) {
        $isbn = trim($node->field_bookcrossing_isbn[LANGUAGE_NONE][0]['value']);

        $isbn = str_replace(' ', "", $isbn);
        $isbn = preg_replace('/([^xX0-9]*)/', "", $isbn);
        if(strlen($isbn) == 10){
            $isbn = '978'.$isbn;
        }elseif(strlen($isbn) != 13){
            $isbn = $node->field_bookcrossing_isbn[LANGUAGE_NONE][0]['value'];
        }
        $node->field_bookcrossing_isbn[LANGUAGE_NONE][0]['value'] = $isbn;
    }
}

/**
 * Form submit for reserved book adding form: save bcid of the book.
 *
 */
function bookcrossing_add_reserved_book($form, &$form_state)
{
    $form_state['bcid'] = $form_state['values']['bcid'];

    // update information about the book
    db_update('bookcrossing_books')
        ->fields(array('nid' => $form_state['values']['nid'], 'status' => BOOKCROSSING_BOOK_STATUS_FREE, 'owner' => -1))
        ->condition('bcid', $form_state['values']['bcid'], '=')
        ->condition('owner', $form_state['values']['uid'], '=')
        ->execute();

    $book = array();
    $book['bid'] = db_select('bookcrossing_books', 'book')
        ->fields('book', array('bid'))
        ->condition('book.bcid', $form_state['values']['bcid'], '=')
        ->execute()
        ->fetchField();

    $book['node'] = node_load($form_state['values']['nid']);
    module_load_include('inc', 'pathauto', 'pathauto');
    pathauto_create_alias('bookcrossing', 'insert', 'book/' . $book['bid'], array('book' => $book));
}


/**
 * Ajax callback: adding values to form elements.
 *
 */

function bookcrossing_autocomplete_form(&$form, &$form_state)
{

    $commands = array();


    $form_state['ajax_used'] = TRUE;


    $first_part = render($form['field_bookcrossing_isbn']);

    $first_part .= render($form['field_bookcrossing_author']);

    $first_part .= render($form['field_bookcrossing_genre']);


    $second_part = render($form['field_bookcrossing_description']);

    $second_part .= render($form['field_bookcrossing_image']);

    $second_part .= render($form['field_bookcrossing_cover']);

    $second_part .= render($form['field_bookcrossing_year']);


    $commands[] = ajax_command_replace("#bookcrossing-first-part", $first_part);

    $commands[] = ajax_command_replace("#bookcrossing-second-part", $second_part);


    return array('#type' => 'ajax', '#commands' => $commands);

}


/**
 * Implements hook_field_extra_fields().
 *
 */
function bookcrossing_field_extra_fields()
{
    $fields['node']['bookcrossing']['display'] = array(
        'book_links' => array(
            'label' => t('Books info links'),
            'description' => t('Links: release book, view history, add to bookmarks.'),
            'weight' => 0,
        ),
        'book_status' => array(
            'label' => t('Book status'),
            'description' => t('Information about current status of the book.'),
            'weight' => 0,
        ),
        'book_found_status' => array(
            'label' => t('Found book status'),
            'description' => t('Status of found book'),
            'weight' => 0,
        ),
        'book_found' => array(
            'label' => t('Where was the book found?'),
            'description' => t('Form for adding place where book was found.'),
            'weight' => 0,
        ),
        'book_comment' => array(
            'label' => t('Book comment'),
            'description' => '',
            'weight' => 0,
        ),
        'book_history' => array(
            'label' => t('Book history'),
            'description' => '',
            'weight' => 0,
        ),
        'bcid' => array(
            'label' => t('BCID'),
            'description' => '',
            'weight' => 0,
        ),
        'history_pager' => array(
            'label' => t('Pager for book history'),
            'description' => '',
            'weight' => 0,
        ),
        'book_status_string' => array(
            'label' => t('Status string'),
            'description' => '',
            'weight' => 0,
        ),
        'author_and_year' => array(
            'label' => t('String with authors and year'),
            'description' => '',
            'weight' => 0,
        ),
    );

    $fields['user']['user']['display'] = array(
        'registered' => array(
            'label' => t('Time of registration'),
            'description' => '',
            'weight' => 0,
        ),
        'book_stats' => array(
            'label' => t('User books'),
            'description' => '',
            'weight' => 0,
        ),
    );

    return $fields;
}


function bookcrossing_ds_fields_info_alter(&$fields, $entity_type)
{

    $fields['ds_user_picture']['function'] = 'bookcrossing_render_user_picture';

    $fields['name']['function'] = 'bookcrossing_render_field';

}


/**
 * Render a field
 *
 */
function bookcrossing_render_field($field)
{
    $output = '';
    $settings = isset($field['formatter_settings']) ? $field['formatter_settings'] : array();
    $settings += $field['properties']['default'];

    // Basic string.
    if (isset($settings['link text'])) {
        $output = t($settings['link text']);
    } elseif (isset($field['properties']['entity_render_key']) && isset($field['entity']->{$field['properties']['entity_render_key']})) {
        if ($field['entity_type'] == 'user' && $field['properties']['entity_render_key'] == 'name') {
            $output = format_username($field['entity']);
        } else {
            $output = $field['entity']->{$field['properties']['entity_render_key']};
        }
    }

    if (empty($output)) {
        return;
    }

    // Link to social profile
    if ($settings['link']) {
        if (isset($field['entity']->uri['path'])) {
            $path = $field['entity']->uri['path'];
        } else {
            $uri_info = entity_uri($field['entity_type'], $field['entity']);
            $path = $uri_info['path'];
        }
        $attributes = array();
        if ($field['entity_type'] == 'user' && $field['properties']['entity_render_key'] == 'name') {
    		if ($user_profile = bookcrossing_get_social_profile($field['entity'])) {
                $path = $user_profile['profileURL'];
                $attributes = array('target' => '_blank');
    		}
        }
        $output = l($output, $path, array('attributes' => $attributes));
    } else {
        $output = check_plain($output);
    }

    // Wrapper and class
    if (!empty($settings['wrapper'])) {
        $wrapper = check_plain($settings['wrapper']);
        $class = (!empty($settings['class'])) ? ' class="' . check_plain($settings['class']) . '"' : '';
        $output = '<' . $wrapper . $class . '>' . $output . '</' . $wrapper . '>';
    }

    return $output;
}


/**
 * Render user picture
 *
 */
function bookcrossing_render_user_picture($field)
{
    $picture = ds_return_picture($field['entity']);

    if (!empty($picture)) {
        $vars = array();
        $filepath = (isset($picture->uri)) ? $picture->uri : $picture;
        $name = !empty($field['entity']->name) ? $field['entity']->name : variable_get('anonymous', t('Anonymous'));
        $alt = t("@user's picture", array('@user' => $name));
        $vars = array('path' => $filepath, 'alt' => $alt, 'title' => $alt);

        // If the image does not have a valid Drupal scheme (for eg. HTTP),
        // don't load image styles.
        if (module_exists('image') && file_valid_uri($filepath)) {
            $vars['style_name'] = str_replace('ds_picture_', '', $field['formatter']);
            $image = theme('image_style', $vars);
        } else {
            $image = theme('image', $vars);
        }

        if (!empty($field['entity']->uid) && user_access('access user profiles')) {
            if ($user_profile = bookcrossing_get_social_profile($field['entity'])) {
                return l($image, $user_profile['profileURL'], array('html' => TRUE, 'attributes' => array('target' => '_blank')));
            } else {
                return l($image, 'user/' . $field['entity']->uid, array('html' => TRUE));
            }
        } else {
            return $image;
        }
    }
}


/**
 * Helper function to get social profile of the user
 *
 */
function bookcrossing_get_social_profile($account)
{
	if ($user_profile = $account->data['hybridauth']) {
		return $user_profile;
	}
}


/**
 * Implements hook_user_view().
 *
 */
function bookcrossing_user_view($account, $view_mode, $langcode)
{
    if ($view_mode == 'user_list') {
        $account->content['registered'] = array(
            '#markup' => '<div class="user-field user-field-registered"><div class="field-label">' . t('Date of registration') . ':' . '</div>' . format_date($account->created, 'custom', 'd F Y') . '</div>',
        );

        $query = db_select('bookcrossing_books', 'b');
        $query->addExpression('COUNT(*)');
        $query->condition('b.status', BOOKCROSSING_BOOK_STATUS_FOUND, '=');
        $query->condition('b.owner', $account->uid, '=');
        $read = $query->execute()->fetchField();

        $output = '<div class="user-stats"><div class="user-field"><div class="field-label">' . t('Reading books') . ':' . '</div>' . $read . '</div>';

        $query = db_select('bookcrossing_books', 'book');
        $query->innerJoin('bookcrossing_history', 'history', 'book.bid = history.book_id');
        $query->distinct();
        $query->addExpression('COUNT(*)');
        $query->condition('book.owner', $account->uid, '<>');
        $query->condition('history.user_id', $account->uid, '=');
        $released = $query->execute()->fetchField();

        $output .= '<div class="user-field"><div class="field-label">' . t('Released user books') . ':' . '</div>' . $released . '</div></div>';

        $account->content['book_stats'] = array(
            '#markup' => $output,
        );
    }
}


/**
 * Implements hook_theme().
 *
 */
function bookcrossing_theme()
{
    return array(
        'bookcrossing_main_menu' => array(
            'variables' => array('links' => NULL, 'visible' => NULL),
        ),
        'book_no_image' => array(
            'variable' => array('book' => NULL),
        ),
    );
}


/**
 * Theme main menu
 *
 */
/**
 * @todo: Important! Move menu layout definition to theme
 */
function theme_bookcrossing_main_menu($variables)
{
    $links = $variables['links'];
    $attributes = $variables['attributes'];
    $heading = $variables['heading'];
    $num_links_visible = $variables['visible'];
    global $language_url;
    $output = '';

    if (count($links) > 0) {
        $output = '';

        // Treat the heading first if it is present to prepend it to the list of links.
        if (!empty($heading)) {
            if (is_string($heading)) {
                // Prepare the array that will be used when the passed heading is a string.
                $heading = array(
                    'text' => $heading,
                    // Set the default level of the heading.
                    'level' => 'h2',
                );
            }
            $output .= '<' . $heading['level'];
            if (!empty($heading['class'])) {
                $output .= drupal_attributes(array('class' => $heading['class']));
            }
            $output .= '>' . check_plain($heading['text']) . '</' . $heading['level'] . '>';
        }

        $output .= '<ul class="nav">';

        $num_links = count($links);
        $i = 1;

        foreach ($links as $key => $link) {
            $class = array($key);

            // Add first, last and active classes to the list of links to help out themers.
            if ($i == 1) {
                $class[] = 'first';
            }

            if ($i == $num_links) {
                $class[] = 'last';
            }

            if (isset($link['href']) && ($link['href'] == $_GET['q'] || ($link['href'] == '<front>' && drupal_is_front_page()))
                && (empty($link['language']) || $link['language']->language == $language_url->language)
            ) {
                $class[] = 'active';
            }

            if ($link['href'] == 'users') {
                $i--;
            }

            if ($i == $num_links_visible) {
                $output .= '
	        <li class="dropdown">
	        	<a href="#" class="dropdown-toggle" data-toggle="dropdown">' . t('more') . '<b class="caret"></b></a>
	            <ul class="dropdown-menu">
            ';
            }

            $output .= '<li' . drupal_attributes(array('class' => $class)) . '>';

            if (isset($link['href'])) {
                if ($link['href'] == 'books' && arg(0) == 'books') {
                    $link['attributes']['class'][] = 'active';
                }

                // Pass in $link as $options, they share the same keys.
                $output .= l($link['title'], $link['href'], $link);
            } elseif (!empty($link['title'])) {
                // Some links are actually not links, but we wrap these in <span> for adding title and class attributes.
                if (empty($link['html'])) {
                    $link['title'] = check_plain($link['title']);
                }
                $span_attributes = '';
                if (isset($link['attributes'])) {
                    $span_attributes = drupal_attributes($link['attributes']);
                }
                $output .= '<span' . $span_attributes . '>' . $link['title'] . '</span>';
            }

            $i++;
            $output .= "</li>";
        }

        $output .= '</ul>';
        $output .= '</li></ul>';
    }

    return $output;
}


/**
 * Theme book when there is image uploaded.
 *
 */
function theme_book_no_image($variables)
{


}


/**
 * Menu callback: add book to bookmarks
 *
 */
function bookcrossing_to_favourites($book = array())
{
    global $user;
    //$bid = isset($_SESSION['book_to_like']) ? $_SESSION['book_to_like'] : '';

    //if (!$bid) {
    //  return '<front>';
    //}

    //$url = url('book/' . $book['bidbid, array('absolute' => TRUE));

    $exist = db_select('bookcrossing_favourites', 'f')
        ->fields('f', array('bid', 'uid'))
        ->condition('uid', $user->uid, '=')
        ->condition('bid', $book['bid'], '=')
        ->execute()
        ->fetchField();

    if ($exist) {
        return ''; //$url;
    }


    db_insert('bookcrossing_favourites')
        ->fields(array('uid' => $user->uid, 'bid' => $book['bid']))
        ->execute();

    drupal_set_title(t('Book was added to your favourites.'));

    drupal_goto('book/' . $book['bid']);
}


function theme_bookcrossing_release_link($variables)
{
    $action = $variables['action'];
    $link = $variables['properties'];
    $url = url($link['href'], array('query' => $link['query']));
    $link['attributes']['class'] = isset($link['attributes']['class']) ? $link['attributes']['class'] : 'facebook-action-like-book';
    $attributes = isset($link['attributes']) ? drupal_attributes($link['attributes']) : '';
    return '<a ' . $attributes . ' href="' . $url . '">' . t('Add to bookmarks') . '</a>';
    return $url;
}


function bookcrossing_form_fboauth_settings_form_alter(&$form, $form_state)
{
    $form['permissions']['fboauth_user_connections']['#options'] += array('publish_actions' => t('Publish actions'));
}


function bookcrossing_user_delete($account)
{
    // release books
    $bids = db_select('bookcrossing_books', 'book')
        ->fields('book', array('bid'))
        ->condition('book.status', BOOKCROSSING_BOOK_STATUS_FOUND, '=')
        ->condition('book.owner', $account->uid, '=')
        ->execute()
        ->fetchCol();

    $books = bookcrossing_load_multiple($bids);
    foreach ($books as $book) {
        db_update('bookcrossing_books')
            ->fields(array(
                'owner' => -1,
                'current_place' => $book['place']->tid,
                'status' => BOOKCROSSING_BOOK_STATUS_FREE,
            ))
            ->condition('bid', $book['bid'], '=')
            ->execute();
// @todo: Check if this update needs to be replaced with INSERT, also check other UPDATE statements for 'bookcrossing_history' table
        db_update('bookcrossing_history')
            ->fields(array('place_id' => $book['place']->tid, 'date_time' => REQUEST_TIME, 'event_type' => BOOKCROSSING_BOOK_STATUS_FREE))
            ->condition('book_id', $book['bid'], '=')
            ->condition('date_time', 0, '=')
            ->execute();
    }

    // delete favourites
    db_delete('bookcrossing_favourites')->condition('uid', $account->uid, '=')->execute();

    // delete comments
    db_delete('bookcrossing_comment')->condition('uid', $account->uid, '=')->execute();

    // delete helper data for user places (not places!!!)
    db_delete('bookcrossing_places')->condition('uid', $account->uid, '=')->execute();

    // change deleted user by admin
    db_update('bookcrossing_history')
        ->fields(array('user_id' => 1))
        ->condition('user_id', $account->uid, '=')
        ->execute();
}
